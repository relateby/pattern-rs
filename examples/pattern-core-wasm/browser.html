<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pattern-core WASM Browser Example</title>
    <style>
        body {
            font-family: monospace;
            max-width: 1200px;
            margin: 40px auto;
            padding: 0 20px;
        }
        h1 { color: #333; }
        pre {
            background: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        .section {
            margin-bottom: 30px;
            border-left: 3px solid #4CAF50;
            padding-left: 15px;
        }
    </style>
</head>
<body>
    <h1>pattern-core WASM Browser Example</h1>
    <p>Open the browser console to see detailed output.</p>
    <div id="output"></div>

    <script type="module">
        // Import the WASM module
        // Adjust path based on where pkg/ is relative to this HTML file
        import init, { Pattern, Subject, Value, ValidationRules } from '../../crates/pattern-core/pkg/pattern_core.js';

        const output = document.getElementById('output');

        function log(title, content) {
            const section = document.createElement('div');
            section.className = 'section';
            section.innerHTML = `<h2>${title}</h2><pre>${content}</pre>`;
            output.appendChild(section);
            console.log(`\n=== ${title} ===`);
            console.log(content);
        }

        async function runExample() {
            // Initialize WASM module
            await init();
            log('Initialization', 'WASM module loaded successfully');

            // 1. Atomic Pattern
            const atomic = Pattern.point("hello");
            log('1. Atomic Pattern',
                `Pattern.point("hello"):\n` +
                `  value: ${atomic.value}\n` +
                `  elements: [${atomic.elements}]\n` +
                `  isAtomic: ${atomic.isAtomic()}\n` +
                `  length: ${atomic.length()}\n` +
                `  size: ${atomic.size()}\n` +
                `  depth: ${atomic.depth()}`
            );

            // 2. Nested Pattern
            const child1 = Pattern.point("child1");
            const child2 = Pattern.point("child2");
            const parent = Pattern.pattern("parent", [child1, child2]);
            log('2. Nested Pattern',
                `Pattern.pattern("parent", [child1, child2]):\n` +
                `  value: ${parent.value}\n` +
                `  length: ${parent.length()}\n` +
                `  size: ${parent.size()}\n` +
                `  depth: ${parent.depth()}\n` +
                `  values: [${parent.values().join(', ')}]`
            );

            // 3. Pattern with Subject
            const subject = Subject.new("n", ["Person"], {
                name: Value.string("Alice"),
                age: Value.int(30)
            });
            const subjectPattern = Pattern.point(subject);
            log('3. Pattern with Subject',
                `Subject with identity "n", label "Person", properties {name, age}:\n` +
                `  identity: ${subject.identity}\n` +
                `  labels: [${Array.from(subject.labels).join(', ')}]\n` +
                `  hasLabel("Person"): ${subject.hasLabel("Person")}\n` +
                `  pattern.value.identity: ${subjectPattern.value.identity}`
            );

            // 4. Map (Transformation)
            const numbers = Pattern.pattern(1, [Pattern.point(2), Pattern.point(3)]);
            const doubled = numbers.map(n => n * 2);
            log('4. Map Transformation',
                `Pattern.pattern(1, [2, 3]).map(n => n * 2):\n` +
                `  original values: [${numbers.values().join(', ')}]\n` +
                `  doubled values: [${doubled.values().join(', ')}]`
            );

            // 5. Filter (Query)
            const filtered = numbers.filter(p => p.value > 1);
            log('5. Filter Query',
                `numbers.filter(p => p.value > 1):\n` +
                `  original length: ${numbers.length()}\n` +
                `  filtered length: ${filtered.length()}\n` +
                `  filtered values: [${filtered.values().join(', ')}]`
            );

            // 6. Fold (Transformation)
            const sum = numbers.fold(0, (acc, val) => acc + val);
            log('6. Fold Transformation',
                `numbers.fold(0, (acc, val) => acc + val):\n` +
                `  sum: ${sum}`
            );

            // 7. Paramorphism (bottom-up fold)
            const tree = Pattern.pattern("root", [
                Pattern.pattern("a", [Pattern.point("a1"), Pattern.point("a2")]),
                Pattern.point("b")
            ]);
            const paraResult = tree.para((value, childResults) => {
                return `(${value} [${childResults.join(', ')}])`;
            });
            log('7. Paramorphism (para)',
                `Bottom-up fold with access to both value and child results:\n` +
                `  structure: root(a(a1, a2), b)\n` +
                `  result: ${paraResult}`
            );

            // 8. Comonad Operations
            const comonadPattern = Pattern.pattern("root", [Pattern.point("child")]);
            const extracted = comonadPattern.extract();
            const depths = comonadPattern.depthAt();
            const sizes = comonadPattern.sizeAt();
            log('8. Comonad Operations',
                `extract(): ${extracted}\n` +
                `depthAt() values: [${depths.values().join(', ')}]\n` +
                `sizeAt() values: [${sizes.values().join(', ')}]`
            );

            // 9. Combination
            const p1 = Pattern.point("hello");
            const p2 = Pattern.point(" world");
            const combined = p1.combine(p2);
            log('9. Combination',
                `Pattern.point("hello").combine(Pattern.point(" world")):\n` +
                `  result: ${combined.value}`
            );

            // 10. Validation (Either-like return)
            const rules = ValidationRules.new({ maxDepth: 2, maxElements: 10 });
            const validResult = numbers.validate(rules);

            const deepPattern = Pattern.pattern("a", [
                Pattern.pattern("b", [
                    Pattern.pattern("c", [Pattern.point("d")])
                ])
            ]);
            const invalidResult = deepPattern.validate(rules);

            log('10. Validation (Either-like)',
                `Validation returns Either-like: { _tag: 'Right' | 'Left', right/left: ... }\n\n` +
                `Valid pattern (depth 1):\n` +
                `  _tag: ${validResult._tag}\n` +
                `  isRight: ${validResult._tag === 'Right'}\n\n` +
                `Invalid pattern (depth 3, maxDepth 2):\n` +
                `  _tag: ${invalidResult._tag}\n` +
                `  isLeft: ${invalidResult._tag === 'Left'}\n` +
                `  error: ${invalidResult._tag === 'Left' ? invalidResult.left.message : 'N/A'}`
            );

            // 11. Structure Analysis
            const analysis = deepPattern.analyzeStructure();
            log('11. Structure Analysis',
                `analyzeStructure() for deep pattern:\n` +
                `  summary: ${analysis.summary}\n` +
                `  depth distribution: [${analysis.depthDistribution.join(', ')}]\n` +
                `  element counts: [${analysis.elementCounts.join(', ')}]`
            );

            // 12. Query Operations
            const hasLargeValue = numbers.anyValue(v => v > 2);
            const allPositive = numbers.allValues(v => v > 0);
            const first = numbers.findFirst(p => p.value > 1);
            const containsTwo = numbers.contains(Pattern.point(2));
            log('12. Query Operations',
                `anyValue(v => v > 2): ${hasLargeValue}\n` +
                `allValues(v => v > 0): ${allPositive}\n` +
                `findFirst(p => p.value > 1): ${first ? first.value : 'null'}\n` +
                `contains(Pattern.point(2)): ${containsTwo}`
            );

            log('Complete', 'All examples executed successfully! âœ“');
        }

        runExample().catch(err => {
            log('Error', err.toString());
            console.error(err);
        });
    </script>
</body>
</html>
