# Implementation Plan: GraphQuery — Portable, Composable Graph Query Interface

**Branch**: `031-graph-query` | **Date**: 2026-02-22 | **Spec**: [spec.md](./spec.md)

---

## Summary

Port `GraphQuery<V>` from the Haskell reference (`../pattern-hs/libs/pattern/src/Pattern/Graph/`) to pattern-rs as a struct-of-closures that abstracts graph traversal over any backing representation. Introduces `TraversalDirection`, `TraversalWeight<V>`, the `GraphQuery<V>` struct, two combinators (`frame_query`, `memoize_incident_rels`), 13 graph algorithms, and 3 context query helpers. All behavior must be equivalent to the Haskell reference; Rust-idiomatic deviations are documented in `research.md`.

---

## Technical Context

**Language/Version**: Rust 1.70.0 (workspace MSRV), Edition 2021
**Primary Dependencies**: `std` only — `HashMap`, `HashSet`, `VecDeque`, `BTreeMap`, `Rc`, `Arc` (no new external crates)
**Storage**: N/A (in-memory only; all state is in `PatternGraph<V>` via `Rc`)
**Testing**: `cargo test` — unit tests + equivalence tests against Haskell reference
**Target Platform**: Native Rust + wasm32-unknown-unknown + Python (via PyO3); `Rc` default, `Arc` via `thread-safe` feature
**Project Type**: Library
**Performance Goals**: Correctness-first; O(1) vtable dispatch per call site is acceptable
**Constraints**: No blocking I/O; no file system access; WASM-compatible closures and data structures
**Scale/Scope**: Single `pattern-core` crate; ~6 new source files; ~400 lines of algorithm code

---

## Constitution Check

| Principle | Status | Notes |
|-----------|--------|-------|
| I. Reference Fidelity | PASS | Ports all 15 Haskell items (types, 9 fields, 2 combinators, 13 algorithms, 3 helpers) |
| II. Correctness & Compatibility | PASS | All algorithms match reference semantics; deviations documented in research.md |
| III. Rust Native Idioms | PASS | Rc/Arc, struct-of-closures, snake_case, Ord/Hash bounds, Option not Maybe |
| IV. Multi-Target Design | PASS | No blocking I/O; Rc closures compile under wasm32-unknown-unknown |
| V. Examples | PASS | quickstart.md provides 8 runnable usage examples |

No constitution violations. Complexity tracking section not needed.

---

## Intentional Deviations from Haskell Reference (documented)

| Item | Haskell | Rust | Rationale |
|------|---------|------|-----------|
| `memoizeIncidentRels` | Lazy Haskell list evaluation | Eager HashMap built at call time | Haskell laziness is implicit; Rust eagerness is explicit. Same amortized complexity. |
| `fromGraphLens` | Available | **Deferred** (GraphLens not yet ported) | GraphLens type doesn't exist in pattern-rs; placeholder TODO comment added |
| `queryCoMembers` signature | `(gq, element, container)` → scans all nodes/rels for co-membership | `(q, element, container)` → uses `container.elements` for O(k) lookup | More efficient in Rust due to direct `elements` field access |
| `degreeCentrality` | No `TraversalWeight` param | No `TraversalWeight` param (corrected from proposal) | Degree is structural, not direction-dependent |
| Context helpers | Take `GraphClassifier` explicitly | Take `&GraphClassifier<Extra, V>` | Matches Haskell; proposal version was simplified incorrectly |

---

## Project Structure

### Documentation (this feature)

```text
specs/031-graph-query/
├── plan.md              # This file
├── research.md          # Phase 0 — design decisions and Haskell findings
├── data-model.md        # Phase 1 — type definitions and module layout
├── quickstart.md        # Phase 1 — usage examples
├── contracts/
│   └── public-api.md    # Phase 1 — full Rust public API surface
└── tasks.md             # Phase 2 — generated by /speckit.tasks
```

### Source Code

```text
crates/pattern-core/
├── Cargo.toml                              update: add thread-safe feature flag
├── src/
│   ├── lib.rs                             update: re-export GraphQuery public API
│   ├── pattern_graph.rs                   update: add from_pattern_graph constructor
│   └── graph/
│       ├── mod.rs                         update: re-export from graph_query + algorithms
│       ├── graph_classifier.rs            existing (030)
│       ├── graph_query.rs                 NEW
│       └── algorithms.rs                  NEW
└── tests/
    ├── graph_query.rs                     NEW: T015–T017, T047–T051, T056
    └── algorithms.rs                      NEW: correctness tests for all algorithms
```

**Structure Decision**: Single project (Option 1). All code lives in `pattern-core`. No sub-crates needed.

---

## Implementation Order

The following order minimizes blocked work and ensures each step compiles independently.

### Step 1 — Cargo.toml: add thread-safe feature

Add `thread-safe = []` to the `[features]` table in `crates/pattern-core/Cargo.toml`. No other code changes yet. Verify the crate still compiles.

### Step 2 — graph_query.rs: types and combinators

Create `crates/pattern-core/src/graph/graph_query.rs` with:

1. `TraversalDirection` enum (`Forward`, `Backward`) — derives `Debug, Clone, Copy, PartialEq, Eq`
2. `TraversalWeight<V>` type alias — `Rc<dyn Fn(&Pattern<V>, TraversalDirection) -> f64>`
3. Canonical weight functions — `undirected`, `directed`, `directed_reverse`
4. `GraphQuery<V>` struct — 9 fields as `Rc<dyn Fn(...)>` with full doc comments and invariant list
5. `Clone` impl for `GraphQuery<V>` — manual `Rc::clone` for each field
6. `frame_query(include, base) -> GraphQuery<V>` combinator
7. `memoize_incident_rels(base) -> GraphQuery<V>` combinator — eager `HashMap` approach

Thread-safe variant: use `#[cfg(feature = "thread-safe")]` to define a type alias `SharedFn<T>` that maps to `Arc<dyn Fn(...) + Send + Sync>` vs `Rc<dyn Fn(...)>`, and apply it to all fields and aliases.

### Step 3 — graph/mod.rs: re-export

Update `crates/pattern-core/src/graph/mod.rs` to:
- Add `pub mod graph_query;`
- Re-export all public items from `graph_query`

### Step 4 — pattern_graph.rs: from_pattern_graph constructor

Add `from_pattern_graph` constructor to `pattern_graph.rs`:

```rust
pub fn from_pattern_graph<V>(graph: Rc<PatternGraph<V>>) -> GraphQuery<V>
where
    V: GraphValue + Clone + Eq,
    V::Id: Clone + Eq + Hash,
```

All 9 fields implemented according to the Haskell reference (`fromPatternGraph` in `Pattern.PatternGraph`):
- `query_nodes` / `query_relationships`: clone and collect from respective HashMaps
- `query_incident_rels`: filter all rels by source-or-target identity match
- `query_source` / `query_target`: first/second element of relationship's elements list
- `query_degree`: count of incident rels (same filter as `query_incident_rels`)
- `query_node_by_id` / `query_relationship_by_id`: HashMap lookups (O(log n) / O(log r))
- `query_containers`: filter across `pg_relationships`, `pg_walks`, `pg_annotations`

Add a TODO comment for the deferred `from_graph_lens` constructor.

### Step 5 — lib.rs: update exports

Update `crates/pattern-core/src/lib.rs` to re-export:
- `TraversalDirection`, `TraversalWeight`
- `undirected`, `directed`, `directed_reverse`
- `GraphQuery`
- `from_pattern_graph`
- `frame_query`, `memoize_incident_rels`

### Step 6 — algorithms.rs: implement all algorithms

Create `crates/pattern-core/src/graph/algorithms.rs` with all 16 items:

**Internal helper** (private):
- `reachable_neighbors(gq, weight, node) -> Vec<Pattern<V>>` — inline-annotated; filters incident rels by finite traversal cost and returns the neighbor node

**Traversal** (2):
- `bfs` — BFS using `VecDeque` queue and `HashSet` visited; returns nodes in visit order including start
- `dfs` — DFS using `Vec` stack; same signature as `bfs`

**Paths** (3):
- `shortest_path` — Dijkstra with `BTreeMap<(OrderedFloat, V::Id), Vec<Pattern<V>>>` as priority queue; same-node case returns `Some(vec![node])`
- `has_path` — delegates to `shortest_path`
- `all_paths` — DFS-based simple-path enumeration; exponential worst case

**Boolean** (2):
- `is_neighbor` — checks if any `reachable_neighbors` result has matching identity
- `is_connected` — empty = true; otherwise `bfs.len() == query_nodes.len()`

**Structural** (3):
- `connected_components` — BFS-per-unvisited-node; returns `Vec<Vec<Pattern<V>>>`
- `topological_sort` — DFS post-order with in-stack cycle detection; returns `Option<Vec<Pattern<V>>>`; ignores weight (uses `query_source`/`query_target` directly)
- `has_cycle` — delegates to `topological_sort`

**Spanning** (1):
- `minimum_spanning_tree` — Kruskal's with path-compression union-find; edge cost = `min(fwd, bwd)`; edges with infinite cost excluded

**Centrality** (2):
- `degree_centrality` — no weight param; normalized `queryDegree / (n-1)` per node
- `betweenness_centrality` — Brandes algorithm using BFS phase + back-propagation; unnormalized; recommend `memoize_incident_rels` wrapper

**Context helpers** (3):
- `query_annotations_of(classifier, q, element)` — filters `query_containers` by `GraphClass::GAnnotation`
- `query_walks_containing(classifier, q, element)` — filters `query_containers` by `GraphClass::GWalk`
- `query_co_members(q, element, container)` — returns elements in `container.elements` excluding `element`

### Step 7 — algorithms re-export

Update `graph/mod.rs` to add `pub mod algorithms;` and re-export algorithm functions.
Update `lib.rs` to re-export `algorithms::*` or individual algorithm functions.

### Step 8 — tests: graph_query.rs

Create `crates/pattern-core/tests/graph_query.rs` with tests mapped to Haskell test IDs:

| Haskell Test ID | Coverage |
|-----------------|----------|
| HS-T015 | Construction: all 9 fields of `GraphQuery` from `from_pattern_graph` return correct results |
| HS-T016 | Equivalence: property test — for any valid `PatternGraph`, `from_pattern_graph` satisfies all 7 structural invariants |
| HS-T017 | TraversalWeight: `undirected`, `directed`, `directed_reverse` return correct costs for Forward/Backward |
| HS-T047 | `frame_query`: nodes outside predicate are excluded from `query_nodes` result |
| HS-T048 | `frame_query`: `query_incident_rels` excludes rels whose endpoints don't satisfy predicate |
| HS-T049 | `memoize_incident_rels`: returns same results as base for all nodes |
| HS-T050 | `memoize_incident_rels`: `query_degree` equals `len(query_incident_rels)` |
| HS-T051 | `frame_query` invariant preservation: all 7 structural invariants hold on framed query |
| HS-T056 | `query_containers`: returns correct containers for nodes appearing in rels and annotations |

### Step 9 — tests: algorithms.rs

Create `crates/pattern-core/tests/algorithms.rs`:

- `bfs` on triangle graph returns all 3 nodes; directed graph from A returns only forward-reachable nodes
- `dfs` on path graph returns nodes in DFS visit order
- `shortest_path` on weighted graph returns minimum-cost path; same node returns `Some([node])`; disconnected returns `None`
- `has_path` returns correct boolean
- `all_paths` on simple graph returns all simple paths
- `connected_components` on disconnected graph returns correct partition
- `topological_sort` on DAG returns valid topological order; cyclic graph returns `None`
- `has_cycle` returns `true` for cyclic, `false` for acyclic
- `minimum_spanning_tree` on 3-node weighted graph
- `degree_centrality`: star graph center has centrality 1.0; leaf has 1/(n-1)
- `betweenness_centrality`: path graph middle node has higher score than endpoints
- Context helpers: `query_annotations_of` returns only annotations; `query_walks_containing` returns only walks; `query_co_members` returns other elements in same container

### Step 10 — CI validation

Run full CI suite:
1. `cargo fmt --all -- --check` — formatting
2. `cargo clippy --workspace -- -D warnings` — linting
3. `cargo build --workspace` — native build
4. `cargo build --workspace --target wasm32-unknown-unknown` — WASM build
5. `cargo test --workspace` — all tests pass
6. `cargo build --workspace --features thread-safe` — thread-safe variant compiles

---

## Key Implementation Notes

### Rc\<dyn Fn\> capture patterns

Each `Rc<PatternGraph<V>>` clone captures into closures. For `from_pattern_graph` with 9 fields, create 9 `Rc::clone` calls upfront — one per field:

```rust
let g1 = Rc::clone(&graph);
let g2 = Rc::clone(&graph);
// ... g9
GraphQuery {
    query_nodes: Rc::new(move || g1.pg_nodes.values().cloned().collect()),
    // ...
}
```

### BTreeMap for Dijkstra priority queue

Rust's `BinaryHeap` requires `Ord` but ties must be broken by node ID. Use `BTreeMap<(OrderedFloat<f64>, V::Id), Vec<Pattern<V>>>` or wrap cost in an `OrderedFloat` newtype. Alternatively, define a local `CostKey(f64, V::Id)` struct with manual `Ord` impl treating NaN as greater than finite values.

Simpler approach: use `BTreeMap<NotNan<f64>, ...>` if ordering cost is available, or just represent costs as integers in unit tests. The implementation should handle `f64` costs correctly per the reference.

### topological_sort: in-stack vs. visited

Two separate `HashSet<V::Id>` values are needed: `visited` (nodes fully processed) and `in_stack` (nodes in current DFS recursion path). A node in `in_stack` but not yet in `visited` indicates a back edge = cycle.

### thread-safe feature

Type alias approach:
```rust
#[cfg(not(feature = "thread-safe"))]
pub(crate) use std::rc::Rc as Shared;

#[cfg(feature = "thread-safe")]
pub(crate) use std::sync::Arc as Shared;
```

For `dyn Fn + Send + Sync`, a macro or conditional typedef for the trait object bound is needed. Simplest approach: define all struct fields using `Shared<dyn Fn(...) + Send + Sync>` and have the non-thread-safe build ignore the unused `Send + Sync` bound (since `Rc<dyn Fn(...)>` satisfies `dyn Fn(...)` without those bounds being checked).

A cleaner approach: define two type aliases in a feature-gated module and import the appropriate one.

### PatternGraph field names

From `crates/pattern-core/src/pattern_graph.rs` (030):
- `pg_nodes: HashMap<V::Id, Pattern<V>>`
- `pg_relationships: HashMap<V::Id, Pattern<V>>`
- `pg_walks: HashMap<V::Id, Pattern<V>>`
- `pg_annotations: HashMap<V::Id, Pattern<V>>`

Use `.values().cloned().collect::<Vec<_>>()` to implement `query_nodes` and `query_relationships`.

For `query_source` / `query_target`, access `rel.elements` (the `Vec<Pattern<V>>` field):
- `source = rel.elements.first().cloned()`
- `target = rel.elements.get(1).cloned()`
