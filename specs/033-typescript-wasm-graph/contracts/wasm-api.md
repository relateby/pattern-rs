# WASM API Contract: Native Graph Types and Algorithms

**Branch**: `033-typescript-wasm-graph`  
**Date**: 2026-02-25  
**Rust source**: `crates/pattern-core/src/wasm.rs` (additions), `crates/pattern-wasm/src/lib.rs`  
**TypeScript entry**: `@relateby/pattern`

All types below are exposed via `wasm-bindgen` and re-exported from `crates/pattern-wasm/src/lib.rs` under `Native*` names. TypeScript declarations are auto-generated by `wasm-pack` with hand-written augmentations declaring that `Native*` classes satisfy the corresponding interfaces from `@relateby/graph`.

The `Native*` prefix distinguishes WASM-backed concrete classes from the pure TypeScript interfaces (`Pattern<V>`, `Subject`, `PatternGraph<V>`, `GraphQuery<V>`) exported from `@relateby/graph`.

---

## Existing Types (renamed)

| Old name | New name (`@relateby/pattern`) | Satisfies interface (`@relateby/graph`) |
|----------|-------------------------------|----------------------------------------|
| `Pattern` (`WasmPattern`) | `NativePattern` | `Pattern<unknown>` |
| `Subject` (`WasmSubject`) | `NativeSubject` | `Subject` |
| `Value` (`ValueFactory`) | `NativeValue` | — (construction only) |
| `ValidationRules` | `NativeValidationRules` | — |
| `StructureAnalysis` | `NativeStructureAnalysis` | — |
| `Gram` | `Gram` (unchanged) | — |

---

## Phase 1: NativePatternGraph + NativeReconciliationPolicy + GraphClass

### `NativePatternGraph`

```typescript
import type { PatternGraph, Subject, Pattern } from "@relateby/graph";

class NativePatternGraph implements PatternGraph<Subject> {
  /** Construct a graph from an array of NativePattern instances. */
  static fromPatterns(
    patterns: NativePattern[],
    policy?: NativeReconciliationPolicy
  ): NativePatternGraph;

  /** Construct an empty graph. */
  static empty(): NativePatternGraph;

  /** All node patterns in the graph. */
  get nodes(): Pattern<Subject>[];

  /** All relationship patterns in the graph. */
  get relationships(): Pattern<Subject>[];

  /** All walk patterns in the graph. */
  get walks(): Pattern<Subject>[];

  /** All annotation patterns in the graph. */
  get annotations(): Pattern<Subject>[];

  /**
   * Identity conflicts recorded under the strict policy.
   * Keys are identity strings; values are arrays of conflicting patterns.
   */
  get conflicts(): Record<string, Pattern<Subject>[]>;

  /** Total count of non-conflict elements. */
  get size(): number;

  /** Merge this graph with another, returning a new graph. Does not mutate. */
  merge(other: NativePatternGraph): NativePatternGraph;

  /**
   * Return patterns in bottom-up shape-class topological order.
   * Used by paraGraph and paraGraphFixed to determine processing order.
   * One WASM crossing; all computation Rust-internal.
   */
  topoSort(): Pattern<Subject>[];
}
```

**Error behavior**: `fromPatterns` never throws; patterns that cannot be deserialized to `Subject` are classified as `other`. `merge` never throws.

---

### `NativeReconciliationPolicy`

```typescript
class NativeReconciliationPolicy {
  /** Incoming pattern replaces existing on identity conflict. */
  static lastWriteWins(): NativeReconciliationPolicy;

  /** Existing pattern is kept; incoming is discarded on identity conflict. */
  static firstWriteWins(): NativeReconciliationPolicy;

  /**
   * Identity conflict is recorded in graph.conflicts.
   * Neither pattern wins; both are preserved in the conflict list.
   */
  static strict(): NativeReconciliationPolicy;

  /**
   * Merge labels and properties per strategy.
   * All options are optional; defaults shown below.
   */
  static merge(options?: {
    elementStrategy?: "replace" | "append" | "union";  // default: "union"
    labelMerge?:      "union" | "intersect" | "left" | "right";  // default: "union"
    propertyMerge?:   "left" | "right" | "merge";  // default: "merge"
  }): NativeReconciliationPolicy;
}
```

---

### `GraphClass` (constant object, not a class)

Exported from `@relateby/pattern` as a convenience re-export of the value from `@relateby/graph`.

```typescript
/** String constants for graph element classification. */
const GraphClass: {
  readonly NODE:         "node";
  readonly RELATIONSHIP: "relationship";
  readonly ANNOTATION:   "annotation";
  readonly WALK:         "walk";
  readonly OTHER:        "other";
};

type GraphClassValue = "node" | "relationship" | "annotation" | "walk" | "other";
```

---

## Phase 2: NativeGraphQuery + Algorithms

### `NativeGraphQuery`

```typescript
import type { GraphQuery, Subject, Pattern } from "@relateby/graph";

class NativeGraphQuery implements GraphQuery<Subject> {
  /** Create a query handle from a NativePatternGraph. */
  static fromPatternGraph(graph: NativePatternGraph): NativeGraphQuery;

  /** All node patterns. */
  nodes(): Pattern<Subject>[];

  /** All relationship patterns. */
  relationships(): Pattern<Subject>[];

  /** Source node of a relationship. Returns null if not found. */
  source(rel: Pattern<Subject>): Pattern<Subject> | null;

  /** Target node of a relationship. Returns null if not found. */
  target(rel: Pattern<Subject>): Pattern<Subject> | null;

  /** All relationships incident to a node (as source or target). */
  incidentRels(node: Pattern<Subject>): Pattern<Subject>[];

  /** Count of incident relationships for a node. */
  degree(node: Pattern<Subject>): number;

  /** Look up a node by its identity string. Returns null if not found. */
  nodeById(identity: string): Pattern<Subject> | null;

  /** Look up a relationship by its identity string. Returns null if not found. */
  relationshipById(identity: string): Pattern<Subject> | null;
}
```

---

### `TraversalDirection` (constant object)

```typescript
const TraversalDirection: {
  readonly FORWARD:  "forward";
  readonly BACKWARD: "backward";
};
```

---

### `Weight` type

```typescript
import type { Pattern, Subject } from "@relateby/graph";

/**
 * Weight specification for traversal algorithms.
 *
 * - "undirected": all edges traversable in both directions (default)
 * - "directed": edges traversable only in their declared direction (forward)
 * - "directed_reverse": edges traversable only in reverse
 * - WeightFn: custom function called once per traversed edge
 *
 * WARNING: WeightFn is called once per traversed edge. For a dense graph
 * with 50,000 edges, this is 50,000 WASM boundary crossings per traversal.
 * Use string constants when possible.
 */
type WeightFn = (rel: Pattern<Subject>, direction: "forward" | "backward") => number;
type Weight = "undirected" | "directed" | "directed_reverse" | WeightFn;
```

---

### Algorithm Functions

All algorithm functions are free functions exported from `@relateby/pattern`. Each function is one WASM crossing; all computation is Rust-internal. All are typed against `@relateby/graph` interfaces.

```typescript
import type { Pattern, Subject } from "@relateby/graph";

function bfs(
  query: NativeGraphQuery,
  start: Pattern<Subject>,
  weight?: Weight
): Pattern<Subject>[];

function dfs(
  query: NativeGraphQuery,
  start: Pattern<Subject>,
  weight?: Weight
): Pattern<Subject>[];

function shortestPath(
  query: NativeGraphQuery,
  start: Pattern<Subject>,
  end: Pattern<Subject>,
  weight?: Weight
): Pattern<Subject>[] | null;

function allPaths(
  query: NativeGraphQuery,
  start: Pattern<Subject>,
  end: Pattern<Subject>,
  weight?: Weight
): Pattern<Subject>[][];

function connectedComponents(
  query: NativeGraphQuery,
  weight?: Weight
): Pattern<Subject>[][];

function hasCycle(query: NativeGraphQuery, weight?: Weight): boolean;

function isConnected(query: NativeGraphQuery, weight?: Weight): boolean;

function topologicalSort(query: NativeGraphQuery): Pattern<Subject>[] | null;

function degreeCentrality(
  query: NativeGraphQuery,
  weight?: Weight
): Record<string, number>;

function betweennessCentrality(
  query: NativeGraphQuery,
  weight?: Weight
): Record<string, number>;

function minimumSpanningTree(
  query: NativeGraphQuery,
  weight?: Weight
): Pattern<Subject>[];

function queryWalksContaining(
  query: NativeGraphQuery,
  node: Pattern<Subject>
): Pattern<Subject>[];

function queryCoMembers(
  query: NativeGraphQuery,
  node: Pattern<Subject>
): Pattern<Subject>[];

function queryAnnotationsOf(
  query: NativeGraphQuery,
  target: Pattern<Subject>
): Pattern<Subject>[];
```

---

## Either/Option Wrappers (TypeScript layer, with Effect)

When Effect is installed, `@relateby/pattern` converts raw WASM returns:

```typescript
import { Either, Option } from "effect";
import type { Pattern, Subject } from "@relateby/graph";

/** Validate a pattern; returns Either<ValidationError, void>. */
export function validate(
  pattern: NativePattern,
  rules: NativeValidationRules
): Either.Either<void, ValidationError>;

/** Shortest path; returns Option<Pattern<Subject>[]>. */
export function shortestPath(
  query: NativeGraphQuery,
  start: Pattern<Subject>,
  end: Pattern<Subject>,
  weight?: Weight
): Option.Option<Pattern<Subject>[]>;

/** Node by ID; returns Option<Pattern<Subject>>. */
export function nodeById(
  query: NativeGraphQuery,
  identity: string
): Option.Option<Pattern<Subject>>;

/** Topological sort; returns Option<Pattern<Subject>[]> (None if cyclic). */
export function topologicalSort(
  query: NativeGraphQuery
): Option.Option<Pattern<Subject>[]>;
```

Without Effect, these functions return the raw `{ _tag: 'Right'/'Left' }` shape or `T | null`.

---

## `.gitignore` additions

```gitignore
typescript/@relateby/pattern/wasm/
typescript/@relateby/pattern/dist/
typescript/@relateby/pattern/node_modules/
typescript/@relateby/gram/wasm/
typescript/@relateby/gram/dist/
typescript/@relateby/gram/node_modules/
typescript/@relateby/graph/dist/
typescript/@relateby/graph/node_modules/
```
