// @relateby/pattern â€” WASM-backed pattern and graph types
//
// This module exports:
// - init(): initialize the WASM module (required in Node.js; auto-init in bundler environments)
// - NativePattern, NativeSubject, NativeValue: core pattern types
// - NativePatternGraph, NativeReconciliationPolicy, NativeGraphQuery: graph types
// - NativeValidationRules, NativeStructureAnalysis: validation types
// - GraphClass, TraversalDirection: constant objects
// - Algorithm free functions: bfs, dfs, shortestPath, etc.
//
// Return types are declared against @relateby/graph interfaces for structural compatibility.

// Re-export @relateby/graph interfaces so users can import from one place
export type {
  Subject,
  Pattern,
  PatternGraph,
  GraphQuery,
  GraphView,
  CategoryMappers,
  GraphClass as GraphClassType,
  Substitution,
} from "@relateby/graph";

export {
  toGraphView,
  GNode,
  GRelationship,
  GWalk,
  GAnnotation,
  GOther,
  DeleteContainer,
  SpliceGap,
  ReplaceWithSurrogate,
  mapGraph,
  mapAllGraph,
  filterGraph,
  foldGraph,
  mapWithContext,
  paraGraph,
  paraGraphFixed,
  unfoldGraph,
} from "@relateby/graph";

import type {
  Subject,
  Pattern,
  PatternGraph,
} from "@relateby/graph";

// ---------------------------------------------------------------------------
// WASM module types (declared; actual types come from wasm-pack generated glue)
// ---------------------------------------------------------------------------

// These type declarations describe the shape of the WASM-generated classes.
// The actual runtime objects come from the wasm/ directory generated by wasm-pack.

export interface NativeSubjectInterface {
  readonly identity: string;
  readonly labels: unknown; // js_sys::Array in WASM
  readonly properties: unknown;
}

export interface NativePatternInterface {
  readonly value: unknown;
  readonly elements: unknown; // js_sys::Array in WASM
  readonly identity: string | undefined;
  readonly length: number;
  isAtomic(): boolean;
}

export interface NativePatternGraphInterface extends PatternGraph<Subject> {
  readonly nodes: ReadonlyArray<Pattern<Subject>>;
  readonly relationships: ReadonlyArray<Pattern<Subject>>;
  readonly walks: ReadonlyArray<Pattern<Subject>>;
  readonly annotations: ReadonlyArray<Pattern<Subject>>;
  readonly conflicts: Readonly<Record<string, ReadonlyArray<Pattern<Subject>>>>;
  readonly size: number;
  merge(other: NativePatternGraphInterface): NativePatternGraphInterface;
  topoSort(): ReadonlyArray<Pattern<Subject>>;
}

export interface NativeGraphQueryInterface {
  nodes(): ReadonlyArray<Pattern<Subject>>;
  relationships(): ReadonlyArray<Pattern<Subject>>;
  source(rel: Pattern<Subject>): Pattern<Subject> | null;
  target(rel: Pattern<Subject>): Pattern<Subject> | null;
  incidentRels(node: Pattern<Subject>): ReadonlyArray<Pattern<Subject>>;
  degree(node: Pattern<Subject>): number;
  nodeById(identity: string): Pattern<Subject> | null;
  relationshipById(identity: string): Pattern<Subject> | null;
}

export interface NativeReconciliationPolicyInterface {
  // opaque handle
}

// ---------------------------------------------------------------------------
// Weight type
// ---------------------------------------------------------------------------

export type WeightFn = (rel: Pattern<Subject>, direction: "forward" | "backward") => number;
export type Weight = "undirected" | "directed" | "directed_reverse" | WeightFn;

// ---------------------------------------------------------------------------
// WASM module initialization
// ---------------------------------------------------------------------------

// The WASM module is lazily loaded. In bundler environments (wasm-pack --target bundler),
// the ES module glue handles initialization via top-level await automatically.
// In Node.js, call `await init()` before using any WASM types.

let wasmModule: WasmExports | null = null;

// The wasm-pack nodejs target exports classes prefixed with "Wasm" (e.g. WasmSubject, WasmPattern).
// The bundler target exports them under their Rust names (Subject, Pattern, NativePatternGraph, etc.).
// WasmExports uses the nodejs naming; the getters in makeProxy handle both via aliasing.
interface WasmExports {
  // Core types (nodejs target: WasmSubject, WasmPattern; bundler target: Subject, Pattern)
  WasmSubject?: { new(identity: string, labels: unknown, properties: unknown): NativeSubjectInterface };
  Subject?: { new(identity: string, labels: unknown, properties: unknown): NativeSubjectInterface };
  WasmPattern?: {
    point(value: unknown): NativePatternInterface;
    of(value: unknown): NativePatternInterface;
    pattern(value: unknown): NativePatternInterface;
  };
  Pattern?: {
    point(value: unknown): NativePatternInterface;
    of(value: unknown): NativePatternInterface;
    pattern(value: unknown): NativePatternInterface;
  };
  Value?: {
    string(s: string): unknown;
    int(n: number): unknown;
    float(n: number): unknown;
    bool(b: boolean): unknown;
    null(): unknown;
  };
  WasmValidationRules?: { new(maxDepth: unknown, maxElements: unknown): unknown };
  ValidationRules?: { new(maxDepth: unknown, maxElements: unknown): unknown };
  // Graph types (nodejs target: WasmPatternGraph, WasmReconciliationPolicy, WasmGraphQuery)
  WasmPatternGraph?: {
    fromPatterns(patterns: unknown[], policy?: unknown): NativePatternGraphInterface;
    empty(): NativePatternGraphInterface;
  };
  NativePatternGraph?: {
    fromPatterns(patterns: unknown[], policy?: unknown): NativePatternGraphInterface;
    empty(): NativePatternGraphInterface;
  };
  WasmReconciliationPolicy?: {
    lastWriteWins(): NativeReconciliationPolicyInterface;
    firstWriteWins(): NativeReconciliationPolicyInterface;
    strict(): NativeReconciliationPolicyInterface;
    merge(options?: unknown): NativeReconciliationPolicyInterface;
  };
  NativeReconciliationPolicy?: {
    lastWriteWins(): NativeReconciliationPolicyInterface;
    firstWriteWins(): NativeReconciliationPolicyInterface;
    strict(): NativeReconciliationPolicyInterface;
    merge(options?: unknown): NativeReconciliationPolicyInterface;
  };
  WasmGraphQuery?: {
    fromPatternGraph(graph: NativePatternGraphInterface): NativeGraphQueryInterface;
  };
  NativeGraphQuery?: {
    fromPatternGraph(graph: NativePatternGraphInterface): NativeGraphQueryInterface;
  };
  // Constant objects
  graph_class_constants?: () => { NODE: string; RELATIONSHIP: string; ANNOTATION: string; WALK: string; OTHER: string };
  traversal_direction_constants?: () => { FORWARD: string; BACKWARD: string };
  // Algorithm functions
  bfs(query: NativeGraphQueryInterface, start: unknown, weight: unknown): unknown[];
  dfs(query: NativeGraphQueryInterface, start: unknown, weight: unknown): unknown[];
  shortestPath(query: NativeGraphQueryInterface, start: unknown, end: unknown, weight: unknown): unknown[] | null;
  allPaths(query: NativeGraphQueryInterface, start: unknown, end: unknown, weight: unknown): unknown[][];
  connectedComponents(query: NativeGraphQueryInterface, weight: unknown): unknown[][];
  hasCycle(query: NativeGraphQueryInterface): boolean;
  isConnected(query: NativeGraphQueryInterface, weight: unknown): boolean;
  topologicalSort(query: NativeGraphQueryInterface): unknown[] | null;
  degreeCentrality(query: NativeGraphQueryInterface): Record<string, number>;
  betweennessCentrality(query: NativeGraphQueryInterface, weight: unknown): Record<string, number>;
  minimumSpanningTree(query: NativeGraphQueryInterface, weight: unknown): unknown[];
  queryWalksContaining(query: NativeGraphQueryInterface, node: unknown): unknown[];
  queryCoMembers(query: NativeGraphQueryInterface, node: unknown, container: unknown): unknown[];
  queryAnnotationsOf(query: NativeGraphQueryInterface, target: unknown): unknown[];
  // Default export (init function from wasm-pack bundler target)
  default?: () => Promise<void>;
}

/**
 * Initialize the WASM module.
 *
 * In Node.js environments, call `await init()` before using any WASM types.
 * In bundler environments (Vite, webpack, Rollup), the wasm-pack --target bundler
 * glue handles initialization automatically via ES module top-level await.
 */
export async function init(): Promise<void> {
  if (wasmModule !== null) return;

  try {
    // In Node.js, use the CJS nodejs-target wasm module via createRequire.
    // In bundler environments, use the ESM bundler-target wasm module.
    const isNode = typeof process !== "undefined" &&
      process.versions != null &&
      process.versions.node != null;

    if (isNode) {
      // Node.js: load the CJS wasm-node module using createRequire
      const { createRequire } = await import("module");
      const { fileURLToPath } = await import("url");
      const { dirname, resolve } = await import("path");
      const __filename = fileURLToPath(import.meta.url);
      const __dirname = dirname(__filename);
      const require = createRequire(import.meta.url);
      const wasmNodePath = resolve(__dirname, "../wasm-node/pattern_wasm.js");
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      wasmModule = require(wasmNodePath) as WasmExports;
    } else {
      // Bundler environment: use the ESM bundler-target wasm module
      const wasmPath = "../wasm/pattern_wasm.js";
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const mod = await import(/* @vite-ignore */ wasmPath) as WasmExports;
      if (typeof mod.default === "function") {
        await mod.default();
      }
      wasmModule = mod;
    }
  } catch (e) {
    throw new Error(
      `Failed to load @relateby/pattern WASM module. ` +
      `Run 'npm run build:wasm && npm run build:wasm:node' to generate the wasm/ directories. ` +
      `Original error: ${e}`
    );
  }
}

function requireWasm(name: string): WasmExports {
  if (wasmModule === null) {
    throw new Error(
      `@relateby/pattern WASM not initialized. Call 'await init()' before using ${name}.`
    );
  }
  return wasmModule;
}

// ---------------------------------------------------------------------------
// Exported WASM-backed constructors
// ---------------------------------------------------------------------------

// These are typed as constructors/namespaces but delegate to the WASM module at runtime.
// They are initialized lazily after init() is called.

type NativeSubjectConstructor = new (
  identity: string,
  labels: string[],
  properties: Record<string, unknown>
) => NativeSubjectInterface;

type NativePatternNamespace = {
  point(value: unknown): NativePatternInterface;
  of(value: unknown): NativePatternInterface;
  pattern(value: unknown): NativePatternInterface;
};

type NativeValueNamespace = {
  string(s: string): unknown;
  int(n: number): unknown;
  float(n: number): unknown;
  bool(b: boolean): unknown;
  null(): unknown;
};

type NativeValidationRulesConstructor = new (maxDepth?: number, maxElements?: number) => unknown;

type NativePatternGraphNamespace = {
  fromPatterns(patterns: NativePatternInterface[], policy?: NativeReconciliationPolicyInterface): NativePatternGraphInterface;
  empty(): NativePatternGraphInterface;
};

type NativeReconciliationPolicyNamespace = {
  lastWriteWins(): NativeReconciliationPolicyInterface;
  firstWriteWins(): NativeReconciliationPolicyInterface;
  strict(): NativeReconciliationPolicyInterface;
  merge(options?: {
    elementStrategy?: "replace" | "append" | "union";
    labelMerge?: "union" | "intersect" | "left" | "right";
    propertyMerge?: "left" | "right" | "merge";
  }): NativeReconciliationPolicyInterface;
};

type NativeGraphQueryNamespace = {
  fromPatternGraph(graph: NativePatternGraphInterface): NativeGraphQueryInterface;
};

function makeProxy<T extends object>(name: string, getter: (wasm: WasmExports) => T): T {
  // Use a function as the proxy target so the `construct` trap fires for `new`.
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  const proxyTarget = function () {} as unknown as T;
  return new Proxy(proxyTarget, {
    get(_target, prop) {
      const wasm = requireWasm(name);
      const target = getter(wasm);
      const val = (target as Record<string | symbol, unknown>)[prop];
      if (typeof val === "function") return val.bind(target);
      return val;
    },
    construct(_target, args) {
      const wasm = requireWasm(name);
      const ctor = getter(wasm) as unknown as new (...a: unknown[]) => object;
      return new ctor(...args);
    },
  });
}

// Helpers to resolve class names that differ between nodejs and bundler wasm-pack targets.
// nodejs target uses "Wasm" prefix (WasmSubject, WasmPattern, etc.)
// bundler target uses Rust names (Subject, Pattern, NativePatternGraph, etc.)
function resolveSubject(wasm: WasmExports) { return (wasm.WasmSubject ?? wasm.Subject)!; }
function resolvePattern(wasm: WasmExports) { return (wasm.WasmPattern ?? wasm.Pattern)!; }
function resolveValue(wasm: WasmExports) { return wasm.Value!; }
function resolveValidationRules(wasm: WasmExports) { return (wasm.WasmValidationRules ?? wasm.ValidationRules)!; }
function resolvePatternGraph(wasm: WasmExports) { return (wasm.WasmPatternGraph ?? wasm.NativePatternGraph)!; }
function resolveReconciliationPolicy(wasm: WasmExports) { return (wasm.WasmReconciliationPolicy ?? wasm.NativeReconciliationPolicy)!; }
function resolveGraphQuery(wasm: WasmExports) { return (wasm.WasmGraphQuery ?? wasm.NativeGraphQuery)!; }

/** WASM-backed Subject constructor. Use as: `new NativeSubject(id, labels, props)` */
export const NativeSubject = makeProxy<NativeSubjectConstructor>(
  "NativeSubject",
  (wasm) => resolveSubject(wasm) as unknown as NativeSubjectConstructor
);

/** WASM-backed Pattern namespace. Use as: `NativePattern.point(subject)` */
export const NativePattern = makeProxy<NativePatternNamespace>(
  "NativePattern",
  (wasm) => resolvePattern(wasm) as unknown as NativePatternNamespace
);

/** WASM-backed Value factory. Use as: `NativeValue.string("hello")` */
export const NativeValue = makeProxy<NativeValueNamespace>(
  "NativeValue",
  (wasm) => resolveValue(wasm) as unknown as NativeValueNamespace
);

/** WASM-backed ValidationRules constructor. */
export const NativeValidationRules = makeProxy<NativeValidationRulesConstructor>(
  "NativeValidationRules",
  (wasm) => resolveValidationRules(wasm) as unknown as NativeValidationRulesConstructor
);

/** WASM-backed PatternGraph namespace. Use as: `NativePatternGraph.fromPatterns([...])` */
export const NativePatternGraph = makeProxy<NativePatternGraphNamespace>(
  "NativePatternGraph",
  (wasm) => resolvePatternGraph(wasm) as unknown as NativePatternGraphNamespace
);

/** WASM-backed ReconciliationPolicy namespace. */
export const NativeReconciliationPolicy = makeProxy<NativeReconciliationPolicyNamespace>(
  "NativeReconciliationPolicy",
  (wasm) => resolveReconciliationPolicy(wasm) as unknown as NativeReconciliationPolicyNamespace
);

/** WASM-backed GraphQuery namespace. */
export const NativeGraphQuery = makeProxy<NativeGraphQueryNamespace>(
  "NativeGraphQuery",
  (wasm) => resolveGraphQuery(wasm) as unknown as NativeGraphQueryNamespace
);

// ---------------------------------------------------------------------------
// GraphClass and TraversalDirection constant objects
// ---------------------------------------------------------------------------

/** String constants for graph element classification. */
export const GraphClass = {
  NODE: "node" as const,
  RELATIONSHIP: "relationship" as const,
  ANNOTATION: "annotation" as const,
  WALK: "walk" as const,
  OTHER: "other" as const,
};
export type GraphClassValue = "node" | "relationship" | "annotation" | "walk" | "other";

/** String constants for traversal direction. */
export const TraversalDirection = {
  FORWARD: "forward" as const,
  BACKWARD: "backward" as const,
};

// ---------------------------------------------------------------------------
// Algorithm free functions
// ---------------------------------------------------------------------------

function resolveWeight(weight?: Weight): unknown {
  if (weight === undefined) return "undirected";
  if (typeof weight === "function") return weight;
  return weight;
}

/** Breadth-first search from a start node. */
export function bfs(
  query: NativeGraphQueryInterface,
  start: Pattern<Subject>,
  weight?: Weight
): Pattern<Subject>[] {
  return requireWasm("bfs").bfs(query, start, resolveWeight(weight)) as Pattern<Subject>[];
}

/** Depth-first search from a start node. */
export function dfs(
  query: NativeGraphQueryInterface,
  start: Pattern<Subject>,
  weight?: Weight
): Pattern<Subject>[] {
  return requireWasm("dfs").dfs(query, start, resolveWeight(weight)) as Pattern<Subject>[];
}

/** Shortest path between two nodes. Returns null if no path exists. */
export function shortestPath(
  query: NativeGraphQueryInterface,
  start: Pattern<Subject>,
  end: Pattern<Subject>,
  weight?: Weight
): Pattern<Subject>[] | null {
  return requireWasm("shortestPath").shortestPath(
    query, start, end, resolveWeight(weight)
  ) as Pattern<Subject>[] | null;
}

/** All paths between two nodes. */
export function allPaths(
  query: NativeGraphQueryInterface,
  start: Pattern<Subject>,
  end: Pattern<Subject>,
  weight?: Weight
): Pattern<Subject>[][] {
  return requireWasm("allPaths").allPaths(
    query, start, end, resolveWeight(weight)
  ) as Pattern<Subject>[][];
}

/** Connected components of the graph. */
export function connectedComponents(
  query: NativeGraphQueryInterface,
  weight?: Weight
): Pattern<Subject>[][] {
  return requireWasm("connectedComponents").connectedComponents(
    query, resolveWeight(weight)
  ) as Pattern<Subject>[][];
}

/** Returns true if the graph contains a directed cycle. */
export function hasCycle(query: NativeGraphQueryInterface): boolean {
  return requireWasm("hasCycle").hasCycle(query);
}

/** Returns true if the graph is connected. */
export function isConnected(query: NativeGraphQueryInterface, weight?: Weight): boolean {
  return requireWasm("isConnected").isConnected(query, resolveWeight(weight));
}

/** Topological sort. Returns null if the graph contains a cycle. */
export function topologicalSort(
  query: NativeGraphQueryInterface
): Pattern<Subject>[] | null {
  return requireWasm("topologicalSort").topologicalSort(query) as Pattern<Subject>[] | null;
}

/** Degree centrality for all nodes. */
export function degreeCentrality(
  query: NativeGraphQueryInterface
): Record<string, number> {
  return requireWasm("degreeCentrality").degreeCentrality(query);
}

/** Betweenness centrality for all nodes. */
export function betweennessCentrality(
  query: NativeGraphQueryInterface,
  weight?: Weight
): Record<string, number> {
  return requireWasm("betweennessCentrality").betweennessCentrality(
    query, resolveWeight(weight)
  );
}

/** Minimum spanning tree. */
export function minimumSpanningTree(
  query: NativeGraphQueryInterface,
  weight?: Weight
): Pattern<Subject>[] {
  return requireWasm("minimumSpanningTree").minimumSpanningTree(
    query, resolveWeight(weight)
  ) as Pattern<Subject>[];
}

/** Returns all walks containing the given node. */
export function queryWalksContaining(
  query: NativeGraphQueryInterface,
  node: Pattern<Subject>
): Pattern<Subject>[] {
  return requireWasm("queryWalksContaining").queryWalksContaining(
    query, node
  ) as Pattern<Subject>[];
}

/** Returns all elements that share a container with the given node. */
export function queryCoMembers(
  query: NativeGraphQueryInterface,
  node: Pattern<Subject>,
  container: Pattern<Subject>
): Pattern<Subject>[] {
  return requireWasm("queryCoMembers").queryCoMembers(
    query, node, container
  ) as Pattern<Subject>[];
}

/** Returns all annotations of the given target element. */
export function queryAnnotationsOf(
  query: NativeGraphQueryInterface,
  target: Pattern<Subject>
): Pattern<Subject>[] {
  return requireWasm("queryAnnotationsOf").queryAnnotationsOf(
    query, target
  ) as Pattern<Subject>[];
}
